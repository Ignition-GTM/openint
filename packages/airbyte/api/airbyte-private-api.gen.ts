/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

export interface paths {
  "/v1/workspaces/create": {
    /** Creates a workspace */
    post: operations["createWorkspace"];
  };
  "/v1/workspaces/delete": {
    /** Deletes a workspace */
    post: operations["deleteWorkspace"];
  };
  "/v1/workspaces/list": {
    /** List all workspaces registered in the current Airbyte deployment */
    post: operations["listWorkspaces"];
  };
  "/v1/workspaces/get": {
    /** Find workspace by ID */
    post: operations["getWorkspace"];
  };
  "/v1/workspaces/get_by_slug": {
    /** Find workspace by slug */
    post: operations["getWorkspaceBySlug"];
  };
  "/v1/workspaces/get_by_connection_id": {
    /** Find workspace by connection id */
    post: operations["getWorkspaceByConnectionId"];
  };
  "/v1/workspaces/update": {
    /** Update workspace state */
    post: operations["updateWorkspace"];
  };
  "/v1/workspaces/update_name": {
    /** Update workspace name */
    post: operations["updateWorkspaceName"];
  };
  "/v1/workspaces/tag_feedback_status_as_done": {
    /** Update workspace feedback state */
    post: operations["updateWorkspaceFeedback"];
  };
  "/v1/notifications/try": {
    /** Try sending a notifications */
    post: operations["tryNotificationConfig"];
  };
  "/v1/source_definitions/update": {
    /** Update a sourceDefinition */
    post: operations["updateSourceDefinition"];
  };
  "/v1/source_definitions/list": {
    /** List all the sourceDefinitions the current Airbyte deployment is configured to use */
    post: operations["listSourceDefinitions"];
  };
  "/v1/source_definitions/list_latest": {
    /**
     * List the latest sourceDefinitions Airbyte supports
     * @description Guaranteed to retrieve the latest information on supported sources.
     */
    post: operations["listLatestSourceDefinitions"];
  };
  "/v1/source_definitions/get": {
    /** Get source */
    post: operations["getSourceDefinition"];
  };
  "/v1/source_definitions/delete": {
    /** Delete a source definition */
    post: operations["deleteSourceDefinition"];
  };
  "/v1/source_definitions/list_private": {
    /** List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
    post: operations["listPrivateSourceDefinitions"];
  };
  "/v1/source_definitions/list_for_workspace": {
    /** List all the sourceDefinitions the given workspace is configured to use */
    post: operations["listSourceDefinitionsForWorkspace"];
  };
  "/v1/source_definitions/create_custom": {
    /** Creates a custom sourceDefinition for the given workspace */
    post: operations["createCustomSourceDefinition"];
  };
  "/v1/source_definitions/get_for_workspace": {
    /** Get a sourceDefinition that is configured for the given workspace */
    post: operations["getSourceDefinitionForWorkspace"];
  };
  "/v1/source_definitions/grant_definition": {
    /** grant a private, non-custom sourceDefinition to a given workspace */
    post: operations["grantSourceDefinitionToWorkspace"];
  };
  "/v1/source_definitions/revoke_definition": {
    /** revoke a grant to a private, non-custom sourceDefinition from a given workspace */
    post: operations["revokeSourceDefinitionFromWorkspace"];
  };
  "/v1/source_definition_specifications/get": {
    /** Get specification for a SourceDefinition. */
    post: operations["getSourceDefinitionSpecification"];
  };
  "/v1/source_definition_specifications/get_for_source": {
    /** Get specification for a source. */
    post: operations["getSpecificationForSourceId"];
  };
  "/v1/declarative_source_definitions/create_manifest": {
    /** Create a declarative manifest to be used by the specified source definition */
    post: operations["createDeclarativeSourceDefinitionManifest"];
  };
  "/v1/declarative_source_definitions/update_active_manifest": {
    /** Update the declarative manifest version for a source */
    post: operations["updateDeclarativeManifestVersion"];
  };
  "/v1/declarative_source_definitions/list_manifests": {
    /** List all available declarative manifest versions of a declarative source definition */
    post: operations["listDeclarativeManifests"];
  };
  "/v1/connector_builder_projects/create": {
    /** Create new connector builder project */
    post: operations["createConnectorBuilderProject"];
  };
  "/v1/connector_builder_projects/publish": {
    /** Publish a connector to the workspace */
    post: operations["publishConnectorBuilderProject"];
  };
  "/v1/connector_builder_projects/update": {
    /** Update connector builder project */
    post: operations["updateConnectorBuilderProject"];
  };
  "/v1/connector_builder_projects/delete": {
    /** Deletes connector builder project */
    post: operations["deleteConnectorBuilderProject"];
  };
  "/v1/connector_builder_projects/list": {
    /** List connector builder projects for workspace */
    post: operations["listConnectorBuilderProjects"];
  };
  "/v1/connector_builder_projects/get_with_manifest": {
    /** Get a connector builder project with draft manifest */
    post: operations["getConnectorBuilderProject"];
  };
  "/v1/sources/create": {
    /** Create a source */
    post: operations["createSource"];
  };
  "/v1/sources/update": {
    /** Update a source */
    post: operations["updateSource"];
  };
  "/v1/sources/partial_update": {
    /** Partially update a source */
    post: operations["partialUpdateSource"];
  };
  "/v1/sources/list": {
    /**
     * List sources for workspace
     * @description List sources for workspace. Does not return deleted sources.
     */
    post: operations["listSourcesForWorkspace"];
  };
  "/v1/sources/get": {
    /** Get source */
    post: operations["getSource"];
  };
  "/v1/sources/most_recent_source_actor_catalog": {
    /** Get most recent ActorCatalog for source */
    post: operations["getMostRecentSourceActorCatalog"];
  };
  "/v1/sources/search": {
    /** Search sources */
    post: operations["searchSources"];
  };
  "/v1/sources/clone": {
    /** Clone source */
    post: operations["cloneSource"];
  };
  "/v1/sources/delete": {
    /** Delete a source */
    post: operations["deleteSource"];
  };
  "/v1/sources/check_connection": {
    /** Check connection to the source */
    post: operations["checkConnectionToSource"];
  };
  "/v1/sources/check_connection_for_update": {
    /** Check connection for a proposed update to a source */
    post: operations["checkConnectionToSourceForUpdate"];
  };
  "/v1/sources/discover_schema": {
    /** Discover the schema catalog of the source */
    post: operations["discoverSchemaForSource"];
  };
  "/v1/sources/apply_schema_changes": {
    /** Auto propagate the change on a catalog to a catalog saved in the DB. It will fetch all the connections linked to a source id and apply the provided diff to their catalog. */
    post: operations["applySchemaChangeForSource"];
  };
  "/v1/sources/write_discover_catalog_result": {
    /** Should only called from worker, to write result from discover activity back to DB. */
    post: operations["writeDiscoverCatalogResult"];
  };
  "/v1/destination_definitions/update": {
    /** Update destinationDefinition */
    post: operations["updateDestinationDefinition"];
  };
  "/v1/destination_definitions/list": {
    /** List all the destinationDefinitions the current Airbyte deployment is configured to use */
    post: operations["listDestinationDefinitions"];
  };
  "/v1/destination_definitions/list_latest": {
    /**
     * List the latest destinationDefinitions Airbyte supports
     * @description Guaranteed to retrieve the latest information on supported destinations.
     */
    post: operations["listLatestDestinationDefinitions"];
  };
  "/v1/destination_definitions/get": {
    /** Get destinationDefinition */
    post: operations["getDestinationDefinition"];
  };
  "/v1/destination_definitions/delete": {
    /** Delete a destination definition */
    post: operations["deleteDestinationDefinition"];
  };
  "/v1/destination_definitions/list_private": {
    /** List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
    post: operations["listPrivateDestinationDefinitions"];
  };
  "/v1/destination_definitions/list_for_workspace": {
    /** List all the destinationDefinitions the given workspace is configured to use */
    post: operations["listDestinationDefinitionsForWorkspace"];
  };
  "/v1/destination_definitions/create_custom": {
    /** Creates a custom destinationDefinition for the given workspace */
    post: operations["createCustomDestinationDefinition"];
  };
  "/v1/destination_definitions/get_for_workspace": {
    /** Get a destinationDefinition that is configured for the given workspace */
    post: operations["getDestinationDefinitionForWorkspace"];
  };
  "/v1/destination_definitions/grant_definition": {
    /** grant a private, non-custom destinationDefinition to a given workspace */
    post: operations["grantDestinationDefinitionToWorkspace"];
  };
  "/v1/destination_definitions/revoke_definition": {
    /** revoke a grant to a private, non-custom destinationDefinition from a given workspace */
    post: operations["revokeDestinationDefinitionFromWorkspace"];
  };
  "/v1/destination_definition_specifications/get": {
    /** Get specification for a destinationDefinition */
    post: operations["getDestinationDefinitionSpecification"];
  };
  "/v1/destination_definition_specifications/get_for_destination": {
    /** Get specification for a destination */
    post: operations["getSpecificationForDestinationId"];
  };
  "/v1/destinations/create": {
    /** Create a destination */
    post: operations["createDestination"];
  };
  "/v1/destinations/update": {
    /** Update a destination */
    post: operations["updateDestination"];
  };
  "/v1/destinations/partial_update": {
    /** Update a destination partially */
    post: operations["partialUpdateDestination"];
  };
  "/v1/destinations/list": {
    /** List configured destinations for a workspace */
    post: operations["listDestinationsForWorkspace"];
  };
  "/v1/destinations/get": {
    /** Get configured destination */
    post: operations["getDestination"];
  };
  "/v1/destinations/search": {
    /** Search destinations */
    post: operations["searchDestinations"];
  };
  "/v1/destinations/check_connection": {
    /** Check connection to the destination */
    post: operations["checkConnectionToDestination"];
  };
  "/v1/destinations/check_connection_for_update": {
    /** Check connection for a proposed update to a destination */
    post: operations["checkConnectionToDestinationForUpdate"];
  };
  "/v1/destinations/delete": {
    /** Delete the destination */
    post: operations["deleteDestination"];
  };
  "/v1/destinations/clone": {
    /** Clone destination */
    post: operations["cloneDestination"];
  };
  "/v1/connections/create": {
    /** Create a connection between a source and a destination */
    post: operations["createConnection"];
  };
  "/v1/connections/update": {
    /**
     * Update a connection
     * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
     * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
     * with the catalog from the request. This means that to modify a single stream, the entire new catalog
     * containing the updated stream needs to be sent.
     */
    post: operations["updateConnection"];
  };
  "/v1/connections/list": {
    /**
     * Returns all connections for a workspace.
     * @description List connections for workspace. Does not return deleted connections.
     */
    post: operations["listConnectionsForWorkspace"];
  };
  "/v1/connections/list_all": {
    /**
     * Returns all connections for a workspace, including deleted connections.
     * @description List connections for workspace, including deleted connections.
     */
    post: operations["listAllConnectionsForWorkspace"];
  };
  "/v1/connections/get": {
    /** Get a connection */
    post: operations["getConnection"];
  };
  "/v1/connections/list_by_actor_definition": {
    /** List all connections that use the provided actor definition */
    post: operations["listConnectionsByActorDefinition"];
  };
  "/v1/state/get": {
    /** Fetch the current state for a connection. */
    post: operations["getState"];
  };
  "/v1/state/create_or_update": {
    /** Create or update the state for a connection. */
    post: operations["createOrUpdateState"];
  };
  "/v1/connections/search": {
    /** Search connections */
    post: operations["searchConnections"];
  };
  "/v1/connections/delete": {
    /** Delete a connection */
    post: operations["deleteConnection"];
  };
  "/v1/connections/sync": {
    /** Trigger a manual sync of the connection */
    post: operations["syncConnection"];
  };
  "/v1/connections/reset": {
    /** Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state. */
    post: operations["resetConnection"];
  };
  "/v1/connections/reset/stream": {
    /** Reset the data for a specific stream in the connection. Deletes data generated by the stream in the destination. Resets any cursors back to initial state. */
    post: operations["resetConnectionStream"];
  };
  "/v1/operations/check": {
    /** Check if an operation to be created is valid */
    post: operations["checkOperation"];
  };
  "/v1/operations/create": {
    /** Create an operation to be applied as part of a connection pipeline */
    post: operations["createOperation"];
  };
  "/v1/operations/update": {
    /** Update an operation */
    post: operations["updateOperation"];
  };
  "/v1/operations/list": {
    /**
     * Returns all operations for a connection.
     * @description List operations for connection.
     */
    post: operations["listOperationsForConnection"];
  };
  "/v1/operations/get": {
    /** Returns an operation */
    post: operations["getOperation"];
  };
  "/v1/operations/delete": {
    /** Delete an operation */
    post: operations["deleteOperation"];
  };
  "/v1/scheduler/sources/check_connection": {
    /** Run check connection for a given source configuration */
    post: operations["executeSourceCheckConnection"];
  };
  "/v1/scheduler/sources/discover_schema": {
    /** Run discover schema for a given source a source configuration */
    post: operations["executeSourceDiscoverSchema"];
  };
  "/v1/scheduler/destinations/check_connection": {
    /** Run check connection for a given destination configuration */
    post: operations["executeDestinationCheckConnection"];
  };
  "/v1/source_oauths/oauth_params/create": {
    /** Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
    post: operations["setInstancewideSourceOauthParams"];
  };
  "/v1/source_oauths/get_consent_url": {
    /** Given a source connector definition ID, return the URL to the consent screen where to redirect the user to. */
    post: operations["getSourceOAuthConsent"];
  };
  "/v1/source_oauths/complete_oauth": {
    /** Given a source def ID generate an access/refresh token etc. */
    post: operations["completeSourceOAuth"];
  };
  "/v1/source_oauths/revoke": {
    /** Given a source definition ID and workspace ID revoke access/refresh token etc. */
    post: operations["revokeSourceOAuthTokens"];
  };
  "/v1/destination_oauths/get_consent_url": {
    /** Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to. */
    post: operations["getDestinationOAuthConsent"];
  };
  "/v1/destination_oauths/complete_oauth": {
    /** Given a destination def ID generate an access/refresh token etc. */
    post: operations["completeDestinationOAuth"];
  };
  "/v1/destination_oauths/oauth_params/create": {
    /** Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
    post: operations["setInstancewideDestinationOauthParams"];
  };
  "/v1/web_backend/check_updates": {
    /** Returns a summary of source and destination definitions that could be updated. */
    post: operations["webBackendCheckUpdates"];
  };
  "/v1/web_backend/connections/list": {
    /** Returns all non-deleted connections for a workspace. */
    post: operations["webBackendListConnectionsForWorkspace"];
  };
  "/v1/web_backend/connections/get": {
    /** Get a connection */
    post: operations["webBackendGetConnection"];
  };
  "/v1/web_backend/connections/create": {
    /** Create a connection */
    post: operations["webBackendCreateConnection"];
  };
  "/v1/web_backend/connections/update": {
    /**
     * Update a connection
     * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
     * Any operations that lack an ID will be created. Then, the newly created operationId will be applied to the
     * connection along with the rest of the operationIds in the request body.
     * Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
     * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
     * with the catalog from the request. This means that to modify a single stream, the entire new catalog
     * containing the updated stream needs to be sent.
     */
    post: operations["webBackendUpdateConnection"];
  };
  "/v1/web_backend/state/get_type": {
    /** Fetch the current state type for a connection. */
    post: operations["getStateType"];
  };
  "/v1/web_backend/workspace/state": {
    /** Returns the current state of a workspace */
    post: operations["webBackendGetWorkspaceState"];
  };
  "/v1/web_backend/geographies/list": {
    /**
     * Returns available geographies can be selected to run data syncs in a particular geography.
     * The 'auto' entry indicates that the sync will be automatically assigned to a geography according
     * to the platform default behavior. Entries other than 'auto' are two-letter country codes that
     * follow the ISO 3166-1 alpha-2 standard.
     *
     * @description Returns all available geographies in which a data sync can run.
     */
    post: operations["webBackendListGeographies"];
  };
  "/v1/jobs/list": {
    /** Returns recent jobs for a connection. Jobs are returned in descending order by createdAt. */
    post: operations["listJobsFor"];
  };
  "/v1/jobs/get": {
    /** Get information about a job */
    post: operations["getJobInfo"];
  };
  "/v1/jobs/get_last_replication_job": {
    post: operations["getLastReplicationJob"];
  };
  "/v1/jobs/get_without_logs": {
    /** Get information about a job excluding logs */
    post: operations["getJobInfoWithoutLogs"];
  };
  "/v1/jobs/get_light": {
    /** Get information about a job excluding attempt info and logs */
    post: operations["getJobInfoLight"];
  };
  "/v1/jobs/cancel": {
    /** Cancels a job */
    post: operations["cancelJob"];
  };
  "/v1/jobs/get_debug_info": {
    /** Gets all information needed to debug this job */
    post: operations["getJobDebugInfo"];
  };
  "/v1/jobs/get_normalization_status": {
    /** Get normalization status to determine if we can bypass normalization phase */
    post: operations["getAttemptNormalizationStatusesForJob"];
  };
  "/v1/health": {
    /** Health Check */
    get: operations["getHealthCheck"];
  };
  "/v1/logs/get": {
    /** Get logs */
    post: operations["getLogs"];
  };
  "/v1/openapi": {
    /** Returns the openapi specification */
    get: operations["getOpenApiSpec"];
  };
  "/v1/attempt/set_workflow_in_attempt": {
    /** For worker to register the workflow id in attempt. */
    post: operations["setWorkflowInAttempt"];
  };
  "/v1/attempt/save_stats": {
    /** For worker to set sync stats of a running attempt. */
    post: operations["saveStats"];
  };
  "/v1/attempt/save_sync_config": {
    /** For worker to save the AttemptSyncConfig for an attempt. */
    post: operations["saveSyncConfig"];
  };
  "/v1/stream_statuses/list": {
    /** Gets a list of stream statuses filtered by parameters (with AND semantics). */
    post: operations["getStreamStatuses"];
  };
  "/v1/stream_statuses/create": {
    /** Creates a stream status. */
    post: operations["createStreamStatus"];
  };
  "/v1/stream_statuses/update": {
    /** Updates a stream status. */
    post: operations["updateStreamStatus"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** Format: uuid */
    WorkspaceId: string;
    /** Format: uuid */
    CustomerId: string;
    WorkspaceCreate: {
      /** Format: email */
      email?: string;
      anonymousDataCollection?: boolean;
      name: string;
      news?: boolean;
      securityUpdates?: boolean;
      notifications?: components["schemas"]["Notification"][];
      notificationSettings?: components["schemas"]["NotificationSettings"];
      displaySetupWizard?: boolean;
      defaultGeography?: components["schemas"]["Geography"];
      webhookConfigs?: components["schemas"]["WebhookConfigWrite"][];
    };
    WebhookConfigWrite: {
      /** @description human readable name for this webhook e.g. for UI display. */
      name?: string;
      /** @description an auth token, to be passed as the value for an HTTP Authorization header. */
      authToken?: string;
      /** @description if supplied, the webhook config will be validated by checking that this URL returns a 2xx response. */
      validationUrl?: string;
    };
    NotificationItem: {
      notificationType?: components["schemas"]["NotificationType"][];
      slackConfiguration?: components["schemas"]["SlackNotificationConfiguration"];
      customerioConfiguration?: components["schemas"]["CustomerioNotificationConfiguration"];
    };
    NotificationSettings: {
      sendOnSuccess?: components["schemas"]["NotificationItem"];
      sendOnFailure?: components["schemas"]["NotificationItem"];
      sendOnSyncDisabled?: components["schemas"]["NotificationItem"];
      sendOnSyncDisabledWarning?: components["schemas"]["NotificationItem"];
      sendOnConnectionUpdate?: components["schemas"]["NotificationItem"];
      sendOnConnectionUpdateActionRequired?: components["schemas"]["NotificationItem"];
    };
    Notification: {
      notificationType: components["schemas"]["NotificationType"];
      /** @default false */
      sendOnSuccess: boolean;
      /** @default true */
      sendOnFailure: boolean;
      slackConfiguration?: components["schemas"]["SlackNotificationConfiguration"];
      customerioConfiguration?: components["schemas"]["CustomerioNotificationConfiguration"];
    };
    SlackNotificationConfiguration: {
      webhook: string;
    };
    CustomerioNotificationConfiguration: Record<string, never>;
    /** @enum {string} */
    NotificationType: "slack" | "customerio";
    NotificationRead: {
      /** @enum {string} */
      status: "succeeded" | "failed";
      message?: string;
    };
    WorkspaceIdRequestBody: {
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    ListConnectionsForWorkspacesRequestBody: {
      workspaceIds: components["schemas"]["WorkspaceId"][];
      /** Format: uuid */
      userId: string;
      pagination?: components["schemas"]["Pagination"];
      /** @default false */
      includeDeleted?: boolean;
    };
    ListResourcesForWorkspacesRequestBody: {
      workspaceIds: components["schemas"]["WorkspaceId"][];
      /** @default false */
      includeDeleted?: boolean;
      pagination?: components["schemas"]["Pagination"];
    };
    WorkspaceReadList: {
      workspaces: components["schemas"]["WorkspaceRead"][];
    };
    WorkspaceRead: {
      workspaceId: components["schemas"]["WorkspaceId"];
      customerId: components["schemas"]["CustomerId"];
      /** Format: email */
      email?: string;
      name: string;
      slug: string;
      initialSetupComplete: boolean;
      displaySetupWizard?: boolean;
      anonymousDataCollection?: boolean;
      news?: boolean;
      securityUpdates?: boolean;
      notifications?: components["schemas"]["Notification"][];
      notificationSettings?: components["schemas"]["NotificationSettings"];
      firstCompletedSync?: boolean;
      feedbackDone?: boolean;
      defaultGeography?: components["schemas"]["Geography"];
      webhookConfigs?: components["schemas"]["WebhookConfigRead"][];
    };
    /** @description the readable info for a webhook config; omits sensitive info e.g. auth token */
    WebhookConfigRead: {
      /** Format: uuid */
      id: string;
      /** @description human-readable name e.g. for display in UI */
      name?: string;
    };
    WorkspaceUpdateName: {
      workspaceId: components["schemas"]["WorkspaceId"];
      name: string;
    };
    /** @description Used to apply a patch-style update to a workspace, which means that null properties remain unchanged */
    WorkspaceUpdate: {
      workspaceId: components["schemas"]["WorkspaceId"];
      /** Format: email */
      email?: string;
      initialSetupComplete?: boolean;
      displaySetupWizard?: boolean;
      anonymousDataCollection?: boolean;
      news?: boolean;
      securityUpdates?: boolean;
      notifications?: components["schemas"]["Notification"][];
      notificationSettings?: components["schemas"]["NotificationSettings"];
      defaultGeography?: components["schemas"]["Geography"];
      webhookConfigs?: components["schemas"]["WebhookConfigWrite"][];
    };
    WorkspaceGiveFeedback: {
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    WebBackendWorkspaceState: {
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    WebBackendWorkspaceStateResult: {
      hasConnections: boolean;
      hasSources: boolean;
      hasDestinations: boolean;
    };
    WebBackendGeographiesListResult: {
      geographies: components["schemas"]["Geography"][];
    };
    SlugRequestBody: {
      slug: string;
    };
    /** @enum {string} */
    Geography: "auto" | "us" | "eu";
    /** Format: uuid */
    ConnectorBuilderProjectId: string;
    /** @description Low code CDK manifest JSON object */
    DeclarativeManifest: Record<string, never>;
    DeclarativeManifestRead: {
      manifest?: components["schemas"]["DeclarativeManifest"];
      isDraft?: boolean;
      version?: components["schemas"]["ManifestVersion"];
      description?: string;
    };
    ConnectorBuilderProjectDetails: {
      name: string;
      draftManifest?: components["schemas"]["DeclarativeManifest"];
    };
    ConnectorBuilderProjectDetailsRead: {
      name: string;
      builderProjectId: components["schemas"]["ConnectorBuilderProjectId"];
      sourceDefinitionId?: components["schemas"]["SourceDefinitionId"];
      activeDeclarativeManifestVersion?: components["schemas"]["ManifestVersion"];
      hasDraft: boolean;
    };
    ConnectorBuilderProjectIdWithWorkspaceId: {
      workspaceId: components["schemas"]["WorkspaceId"];
      builderProjectId: components["schemas"]["ConnectorBuilderProjectId"];
      version?: components["schemas"]["ManifestVersion"];
    };
    ExistingConnectorBuilderProjectWithWorkspaceId: {
      workspaceId: components["schemas"]["WorkspaceId"];
      builderProjectId: components["schemas"]["ConnectorBuilderProjectId"];
      builderProject: components["schemas"]["ConnectorBuilderProjectDetails"];
    };
    ConnectorBuilderProjectWithWorkspaceId: {
      workspaceId: components["schemas"]["WorkspaceId"];
      builderProject: components["schemas"]["ConnectorBuilderProjectDetails"];
    };
    ConnectorBuilderProjectRead: {
      builderProject: components["schemas"]["ConnectorBuilderProjectDetailsRead"];
      declarativeManifest?: components["schemas"]["DeclarativeManifestRead"];
    };
    ConnectorBuilderProjectReadList: {
      projects: components["schemas"]["ConnectorBuilderProjectDetailsRead"][];
    };
    ConnectorBuilderPublishRequestBody: {
      workspaceId: components["schemas"]["WorkspaceId"];
      builderProjectId: components["schemas"]["ConnectorBuilderProjectId"];
      name: string;
      initialDeclarativeManifest: components["schemas"]["DeclarativeSourceManifest"];
    };
    /** Format: int64 */
    ManifestVersion: number;
    DeclarativeSourceManifest: {
      description: string;
      manifest: components["schemas"]["DeclarativeManifest"];
      spec: components["schemas"]["SourceDefinitionSpecification"];
      version: components["schemas"]["ManifestVersion"];
    };
    SourceDefinitionIdBody: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
    };
    /** Format: uuid */
    SourceDefinitionId: string;
    SourceDefinitionIdRequestBody: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
    };
    SourceDefinitionCreate: {
      name: string;
      dockerRepository: string;
      dockerImageTag: string;
      /** Format: uri */
      documentationUrl: string;
      icon?: string;
      resourceRequirements?: components["schemas"]["ActorDefinitionResourceRequirements"];
    };
    /** @description Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version. */
    SourceDefinitionUpdate: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      dockerImageTag: string;
      resourceRequirements?: components["schemas"]["ActorDefinitionResourceRequirements"];
    };
    SourceDefinitionRead: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      name: string;
      dockerRepository: string;
      dockerImageTag: string;
      /** Format: uri */
      documentationUrl?: string;
      icon?: string;
      /** @description The Airbyte Protocol version supported by the connector */
      protocolVersion?: string;
      releaseStage?: components["schemas"]["ReleaseStage"];
      /**
       * Format: date
       * @description The date when this connector was first released, in yyyy-mm-dd format.
       */
      releaseDate?: string;
      /** @enum {string} */
      sourceType?: "api" | "file" | "database" | "custom";
      resourceRequirements?: components["schemas"]["ActorDefinitionResourceRequirements"];
      /**
       * Format: int64
       * @description Number of seconds allowed between 2 airbyte protocol messages. The source will timeout if this delay is reach
       */
      maxSecondsBetweenMessages?: number;
    };
    SourceDefinitionReadList: {
      sourceDefinitions: components["schemas"]["SourceDefinitionRead"][];
    };
    CustomSourceDefinitionCreate: {
      workspaceId: components["schemas"]["WorkspaceId"];
      sourceDefinition: components["schemas"]["SourceDefinitionCreate"];
    };
    SourceDefinitionIdWithWorkspaceId: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    ListDeclarativeManifestsRequestBody: {
      workspaceId: components["schemas"]["WorkspaceId"];
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
    };
    DeclarativeManifestsReadList: {
      manifestVersions: components["schemas"]["DeclarativeManifestVersionRead"][];
    };
    DeclarativeManifestVersionRead: {
      /** Format: int64 */
      version: number;
      isActive: boolean;
      description: string;
    };
    DeclarativeSourceDefinitionCreateManifestRequestBody: {
      workspaceId: components["schemas"]["WorkspaceId"];
      sourceDefinitionId: components["schemas"]["ConnectorBuilderProjectId"];
      setAsActiveManifest: boolean;
      declarativeManifest: components["schemas"]["DeclarativeSourceManifest"];
    };
    UpdateActiveManifestRequestBody: {
      workspaceId: components["schemas"]["WorkspaceId"];
      sourceDefinitionId: components["schemas"]["ConnectorBuilderProjectId"];
      version: components["schemas"]["ManifestVersion"];
    };
    PrivateSourceDefinitionRead: {
      sourceDefinition: components["schemas"]["SourceDefinitionRead"];
      granted: boolean;
    };
    PrivateSourceDefinitionReadList: {
      sourceDefinitions: components["schemas"]["PrivateSourceDefinitionRead"][];
    };
    /**
     * @description The specification for what values are required to configure the sourceDefinition.
     * @example {
     *   "user": {
     *     "type": "string"
     *   }
     * }
     */
    SourceDefinitionSpecification: Record<string, never>;
    SourceDefinitionSpecificationRead: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      documentationUrl?: string;
      connectionSpecification?: components["schemas"]["SourceDefinitionSpecification"];
      advancedAuth?: components["schemas"]["AdvancedAuth"];
      jobInfo: components["schemas"]["SynchronousJobRead"];
    };
    /** Format: uuid */
    SourceId: string;
    SourceIdRequestBody: {
      sourceId: components["schemas"]["SourceId"];
    };
    /** @description The values required to configure the source. The schema for this should have an id of the existing source along with the configuration you want to change in case. */
    SourceCloneRequestBody: {
      sourceCloneId: components["schemas"]["SourceId"];
      sourceConfiguration?: components["schemas"]["SourceCloneConfiguration"];
    };
    SourceCloneConfiguration: {
      connectionConfiguration?: components["schemas"]["SourceConfiguration"];
      name?: string;
    };
    /**
     * @description The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
     * @example {
     *   "user": "charles"
     * }
     */
    SourceConfiguration: unknown;
    SourceCoreConfig: {
      sourceId?: components["schemas"]["SourceId"];
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      connectionConfiguration: components["schemas"]["SourceConfiguration"];
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    SourceCreate: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      connectionConfiguration: components["schemas"]["SourceConfiguration"];
      workspaceId: components["schemas"]["WorkspaceId"];
      name: string;
      /** @example airbyte_oauth_workspace_0509f049-d671-48cb-8105-0a23d47e6db6_secret_e0d38206-034e-4d75-9d21-da5a99b02826_v1 */
      secretId?: string;
    };
    SourceDiscoverSchemaRequestBody: {
      sourceId: components["schemas"]["SourceId"];
      /** Format: uuid */
      connectionId?: string;
      disable_cache?: boolean;
      notifySchemaChange?: boolean;
    };
    PartialSourceUpdate: {
      sourceId: components["schemas"]["SourceId"];
      connectionConfiguration?: components["schemas"]["SourceConfiguration"];
      name?: string;
      /** @example airbyte_oauth_workspace_0509f049-d671-48cb-8105-0a23d47e6db6_secret_e0d38206-034e-4d75-9d21-da5a99b02826_v1 */
      secretId?: string;
    };
    SourceUpdate: {
      sourceId: components["schemas"]["SourceId"];
      connectionConfiguration: components["schemas"]["SourceConfiguration"];
      name: string;
      /** @example airbyte_oauth_workspace_0509f049-d671-48cb-8105-0a23d47e6db6_secret_e0d38206-034e-4d75-9d21-da5a99b02826_v1 */
      secretId?: string;
    };
    SourceRead: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      sourceId: components["schemas"]["SourceId"];
      workspaceId: components["schemas"]["WorkspaceId"];
      connectionConfiguration: components["schemas"]["SourceConfiguration"];
      name: string;
      sourceName: string;
      icon?: string;
    };
    SourceSnippetRead: {
      sourceId: components["schemas"]["SourceId"];
      name: string;
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      sourceName: string;
      icon?: string;
    };
    SourceReadList: {
      sources: components["schemas"]["SourceRead"][];
    };
    /** @description to write this requested object to database. */
    SourceDiscoverSchemaWriteRequestBody: {
      catalog: components["schemas"]["AirbyteCatalog"];
      sourceId?: components["schemas"]["SourceId"];
      connectorVersion?: string;
      configurationHash?: string;
    };
    /** @description Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not. */
    SourceDiscoverSchemaRead: {
      catalog?: components["schemas"]["AirbyteCatalog"];
      jobInfo: components["schemas"]["SynchronousJobRead"];
      /** Format: uuid */
      catalogId?: string;
      catalogDiff?: components["schemas"]["CatalogDiff"];
      breakingChange?: boolean;
      connectionStatus?: components["schemas"]["ConnectionStatus"];
    };
    /** @description Input of the source propagation, it contains the discovered catalog and a list of diff that need to be applied to the existing catalog. */
    SourceAutoPropagateChange: {
      catalog: components["schemas"]["AirbyteCatalog"];
      /** Format: uuid */
      catalogId: string;
      /** Format: uuid */
      sourceId: string;
      /** Format: uuid */
      workspaceId: string;
    };
    SourceSearch: {
      sourceDefinitionId?: components["schemas"]["SourceDefinitionId"];
      sourceId?: components["schemas"]["SourceId"];
      workspaceId?: components["schemas"]["WorkspaceId"];
      connectionConfiguration?: components["schemas"]["SourceConfiguration"];
      name?: string;
      sourceName?: string;
    };
    /** Format: uuid */
    DestinationDefinitionId: string;
    DestinationDefinitionIdRequestBody: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
    };
    DestinationDefinitionCreate: {
      name: string;
      dockerRepository: string;
      dockerImageTag: string;
      /** Format: uri */
      documentationUrl: string;
      icon?: string;
      resourceRequirements?: components["schemas"]["ActorDefinitionResourceRequirements"];
    };
    DestinationDefinitionUpdate: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      dockerImageTag?: string;
      resourceRequirements?: components["schemas"]["ActorDefinitionResourceRequirements"];
    };
    DestinationDefinitionRead: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      name: string;
      dockerRepository: string;
      dockerImageTag: string;
      /** Format: uri */
      documentationUrl: string;
      icon?: string;
      /** @description The Airbyte Protocol version supported by the connector */
      protocolVersion?: string;
      releaseStage?: components["schemas"]["ReleaseStage"];
      /**
       * Format: date
       * @description The date when this connector was first released, in yyyy-mm-dd format.
       */
      releaseDate?: string;
      resourceRequirements?: components["schemas"]["ActorDefinitionResourceRequirements"];
      /** @description an optional flag indicating whether DBT is used in the normalization. If the flag value is NULL - DBT is not used. */
      supportsDbt: boolean;
      normalizationConfig: components["schemas"]["NormalizationDestinationDefinitionConfig"];
    };
    DestinationDefinitionReadList: {
      destinationDefinitions: components["schemas"]["DestinationDefinitionRead"][];
    };
    CustomDestinationDefinitionCreate: {
      workspaceId: components["schemas"]["WorkspaceId"];
      destinationDefinition: components["schemas"]["DestinationDefinitionCreate"];
    };
    DestinationDefinitionIdWithWorkspaceId: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    PrivateDestinationDefinitionRead: {
      destinationDefinition: components["schemas"]["DestinationDefinitionRead"];
      granted: boolean;
    };
    PrivateDestinationDefinitionReadList: {
      destinationDefinitions: components["schemas"]["PrivateDestinationDefinitionRead"][];
    };
    /**
     * @description The specification for what values are required to configure the destinationDefinition.
     * @example {
     *   "user": {
     *     "type": "string"
     *   }
     * }
     */
    DestinationDefinitionSpecification: Record<string, never>;
    DestinationDefinitionSpecificationRead: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      documentationUrl?: string;
      connectionSpecification?: components["schemas"]["DestinationDefinitionSpecification"];
      advancedAuth?: components["schemas"]["AdvancedAuth"];
      jobInfo: components["schemas"]["SynchronousJobRead"];
      supportedDestinationSyncModes?: components["schemas"]["DestinationSyncMode"][];
    };
    /** Format: uuid */
    DestinationId: string;
    DestinationIdRequestBody: {
      destinationId: components["schemas"]["DestinationId"];
    };
    /**
     * @description The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
     * @example {
     *   "user": "charles"
     * }
     */
    DestinationConfiguration: unknown;
    DestinationCoreConfig: {
      destinationId?: components["schemas"]["DestinationId"];
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      connectionConfiguration: components["schemas"]["DestinationConfiguration"];
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    DestinationCreate: {
      workspaceId: components["schemas"]["WorkspaceId"];
      name: string;
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      connectionConfiguration: components["schemas"]["DestinationConfiguration"];
    };
    DestinationUpdate: {
      destinationId: components["schemas"]["DestinationId"];
      connectionConfiguration: components["schemas"]["DestinationConfiguration"];
      name: string;
    };
    PartialDestinationUpdate: {
      destinationId?: components["schemas"]["DestinationId"];
      connectionConfiguration?: components["schemas"]["DestinationConfiguration"];
      name?: string;
    };
    /** @description The values required to configure the destination. The schema for this should have an id of the existing destination along with the configuration you want to change in case. */
    DestinationCloneRequestBody: {
      destinationCloneId: components["schemas"]["DestinationId"];
      destinationConfiguration?: components["schemas"]["DestinationCloneConfiguration"];
    };
    DestinationCloneConfiguration: {
      connectionConfiguration?: components["schemas"]["DestinationConfiguration"];
      name?: string;
    };
    DestinationRead: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      destinationId: components["schemas"]["DestinationId"];
      workspaceId: components["schemas"]["WorkspaceId"];
      connectionConfiguration: components["schemas"]["DestinationConfiguration"];
      name: string;
      destinationName: string;
      icon?: string;
    };
    DestinationSnippetRead: {
      destinationId: components["schemas"]["DestinationId"];
      name: string;
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      destinationName: string;
      icon?: string;
    };
    DestinationReadList: {
      destinations: components["schemas"]["DestinationRead"][];
    };
    DestinationSearch: {
      destinationDefinitionId?: components["schemas"]["DestinationDefinitionId"];
      destinationId?: components["schemas"]["DestinationId"];
      workspaceId?: components["schemas"]["WorkspaceId"];
      connectionConfiguration?: components["schemas"]["DestinationConfiguration"];
      name?: string;
      destinationName?: string;
    };
    /** @enum {string} */
    ReleaseStage: "alpha" | "beta" | "generally_available" | "custom";
    /** Format: uuid */
    ConnectionId: string;
    ConnectionIdRequestBody: {
      connectionId: components["schemas"]["ConnectionId"];
    };
    ConnectionStream: {
      streamName: string;
      streamNamespace: string;
    };
    ConnectionStreamRequestBody: {
      connectionId: components["schemas"]["ConnectionId"];
      streams: components["schemas"]["ConnectionStream"][];
    };
    DbMigrationRequestBody: {
      database: string;
    };
    WebBackendConnectionRequestBody: {
      withRefreshedCatalog?: boolean;
      connectionId: components["schemas"]["ConnectionId"];
    };
    ConnectionCreate: {
      /** @description Optional name of the connection */
      name?: string;
      namespaceDefinition?: components["schemas"]["NamespaceDefinitionType"];
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string;
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string;
      sourceId: components["schemas"]["SourceId"];
      destinationId: components["schemas"]["DestinationId"];
      operationIds?: components["schemas"]["OperationId"][];
      syncCatalog?: components["schemas"]["AirbyteCatalog"];
      schedule?: components["schemas"]["ConnectionSchedule"];
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status: components["schemas"]["ConnectionStatus"];
      resourceRequirements?: components["schemas"]["ResourceRequirements"];
      /** Format: uuid */
      sourceCatalogId?: string;
      geography?: components["schemas"]["Geography"];
      notifySchemaChanges?: boolean;
      notifySchemaChangesByEmail?: boolean;
      nonBreakingChangesPreference?: components["schemas"]["NonBreakingChangesPreference"];
    };
    WebBackendConnectionCreate: {
      /** @description Optional name of the connection */
      name?: string;
      namespaceDefinition?: components["schemas"]["NamespaceDefinitionType"];
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string;
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string;
      sourceId: components["schemas"]["SourceId"];
      destinationId: components["schemas"]["DestinationId"];
      operationIds?: components["schemas"]["OperationId"][];
      syncCatalog?: components["schemas"]["AirbyteCatalog"];
      schedule?: components["schemas"]["ConnectionSchedule"];
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status: components["schemas"]["ConnectionStatus"];
      resourceRequirements?: components["schemas"]["ResourceRequirements"];
      operations?: components["schemas"]["OperationCreate"][];
      /** Format: uuid */
      sourceCatalogId?: string;
      geography?: components["schemas"]["Geography"];
      nonBreakingChangesPreference?: components["schemas"]["NonBreakingChangesPreference"];
    };
    ConnectionStateCreateOrUpdate: {
      connectionId: components["schemas"]["ConnectionId"];
      connectionState: components["schemas"]["ConnectionState"];
    };
    /** @description Used to apply a patch-style update to a connection, which means that null properties remain unchanged */
    ConnectionUpdate: {
      connectionId: components["schemas"]["ConnectionId"];
      namespaceDefinition?: components["schemas"]["NamespaceDefinitionType"];
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string;
      /** @description Name that will be set to this connection */
      name?: string;
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string;
      operationIds?: components["schemas"]["OperationId"][];
      syncCatalog?: components["schemas"]["AirbyteCatalog"];
      schedule?: components["schemas"]["ConnectionSchedule"];
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status?: components["schemas"]["ConnectionStatus"];
      resourceRequirements?: components["schemas"]["ResourceRequirements"];
      /** Format: uuid */
      sourceCatalogId?: string;
      geography?: components["schemas"]["Geography"];
      notifySchemaChanges?: boolean;
      notifySchemaChangesByEmail?: boolean;
      nonBreakingChangesPreference?: components["schemas"]["NonBreakingChangesPreference"];
      breakingChange?: boolean;
    };
    /** @description Used to apply a patch-style update to a connection, which means that null properties remain unchanged */
    WebBackendConnectionUpdate: {
      /** @description Name that will be set to the connection */
      name?: string;
      connectionId: components["schemas"]["ConnectionId"];
      namespaceDefinition?: components["schemas"]["NamespaceDefinitionType"];
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string;
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string;
      syncCatalog?: components["schemas"]["AirbyteCatalog"];
      schedule?: components["schemas"]["ConnectionSchedule"];
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status?: components["schemas"]["ConnectionStatus"];
      resourceRequirements?: components["schemas"]["ResourceRequirements"];
      skipReset?: boolean;
      operations?: components["schemas"]["WebBackendOperationCreateOrUpdate"][];
      /** Format: uuid */
      sourceCatalogId?: string;
      geography?: components["schemas"]["Geography"];
      notifySchemaChanges?: boolean;
      notifySchemaChangesByEmail?: boolean;
      nonBreakingChangesPreference?: components["schemas"]["NonBreakingChangesPreference"];
    };
    ConnectionRead: {
      connectionId: components["schemas"]["ConnectionId"];
      name: string;
      namespaceDefinition?: components["schemas"]["NamespaceDefinitionType"];
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string;
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string;
      sourceId: components["schemas"]["SourceId"];
      destinationId: components["schemas"]["DestinationId"];
      operationIds?: components["schemas"]["OperationId"][];
      syncCatalog: components["schemas"]["AirbyteCatalog"];
      schedule?: components["schemas"]["ConnectionSchedule"];
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status: components["schemas"]["ConnectionStatus"];
      resourceRequirements?: components["schemas"]["ResourceRequirements"];
      /** Format: uuid */
      sourceCatalogId?: string;
      geography?: components["schemas"]["Geography"];
      breakingChange: boolean;
      notifySchemaChanges?: boolean;
      notifySchemaChangesByEmail?: boolean;
      nonBreakingChangesPreference?: components["schemas"]["NonBreakingChangesPreference"];
      workspaceId?: components["schemas"]["WorkspaceId"];
    };
    /** @enum {string} */
    SchemaChange: "no_change" | "non_breaking" | "breaking";
    ConnectionSearch: {
      connectionId?: components["schemas"]["ConnectionId"];
      name?: string;
      namespaceDefinition?: components["schemas"]["NamespaceDefinitionType"];
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string;
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string;
      sourceId?: components["schemas"]["SourceId"];
      destinationId?: components["schemas"]["DestinationId"];
      schedule?: components["schemas"]["ConnectionSchedule"];
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status?: components["schemas"]["ConnectionStatus"];
      source?: components["schemas"]["SourceSearch"];
      destination?: components["schemas"]["DestinationSearch"];
    };
    ConnectionReadList: {
      connections: components["schemas"]["ConnectionRead"][];
    };
    /**
     * @description Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
     * @enum {string}
     */
    ConnectionStatus: "active" | "inactive" | "deprecated";
    /** @description if null, then no schedule is set. */
    ConnectionSchedule: {
      /** Format: int64 */
      units: number;
      /** @enum {string} */
      timeUnit: "minutes" | "hours" | "days" | "weeks" | "months";
    };
    /**
     * @description determine how the schedule data should be interpreted
     * @enum {string}
     */
    ConnectionScheduleType: "manual" | "basic" | "cron";
    /** @description schedule for when the the connection should run, per the schedule type */
    ConnectionScheduleData: {
      basicSchedule?: {
        /** @enum {string} */
        timeUnit: "minutes" | "hours" | "days" | "weeks" | "months";
        /** Format: int64 */
        units: number;
      };
      cron?: {
        cronExpression: string;
        cronTimeZone: string;
      };
    };
    /**
     * @description Method used for computing final namespace in destination
     * @enum {string}
     */
    NamespaceDefinitionType: "source" | "destination" | "customformat";
    /** Format: uuid */
    OperationId: string;
    OperationIdRequestBody: {
      operationId: components["schemas"]["OperationId"];
    };
    OperationCreate: {
      workspaceId: components["schemas"]["WorkspaceId"];
      name: string;
      operatorConfiguration: components["schemas"]["OperatorConfiguration"];
    };
    OperationUpdate: {
      operationId: components["schemas"]["OperationId"];
      name: string;
      operatorConfiguration: components["schemas"]["OperatorConfiguration"];
    };
    WebBackendOperationCreateOrUpdate: {
      operationId?: components["schemas"]["OperationId"];
      workspaceId: components["schemas"]["WorkspaceId"];
      name: string;
      operatorConfiguration: components["schemas"]["OperatorConfiguration"];
    };
    OperationRead: {
      workspaceId: components["schemas"]["WorkspaceId"];
      operationId: components["schemas"]["OperationId"];
      name: string;
      operatorConfiguration: components["schemas"]["OperatorConfiguration"];
    };
    OperationReadList: {
      operations: components["schemas"]["OperationRead"][];
    };
    OperatorConfiguration: {
      operatorType: components["schemas"]["OperatorType"];
      normalization?: components["schemas"]["OperatorNormalization"];
      dbt?: components["schemas"]["OperatorDbt"];
      webhook?: components["schemas"]["OperatorWebhook"];
    };
    /** @enum {string} */
    OperatorType: "normalization" | "dbt" | "webhook";
    OperatorNormalization: {
      /** @enum {string} */
      option?: "basic";
    };
    OperatorDbt: {
      gitRepoUrl: string;
      gitRepoBranch?: string;
      dockerImage?: string;
      dbtArguments?: string;
    };
    OperatorWebhook: {
      /**
       * Format: uuid
       * @description The id of the webhook configs to use from the workspace.
       */
      webhookConfigId?: string;
      /** @enum {string} */
      webhookType?: "dbtCloud";
      dbtCloud?: {
        /** @description The account id associated with the job */
        accountId: number;
        /** @description The job id associated with the job */
        jobId: number;
      };
      /**
       * @deprecated
       * @description DEPRECATED. Populate dbtCloud instead.
       */
      executionUrl?: string;
      /**
       * @deprecated
       * @description DEPRECATED. Populate dbtCloud instead.
       */
      executionBody?: string;
    };
    CheckOperationRead: {
      /** @enum {string} */
      status: "succeeded" | "failed";
      message?: string;
    };
    /**
     * @description type/source of logs produced
     * @enum {string}
     */
    LogType: "server" | "scheduler";
    LogsRequestBody: {
      logType: components["schemas"]["LogType"];
    };
    /** @description A source actor catalog with the timestamp it was mostly recently updated */
    ActorCatalogWithUpdatedAt: {
      /** Format: int64 */
      updatedAt?: number;
      catalog?: Record<string, never>;
    };
    /** @description describes the available schema (catalog). */
    AirbyteCatalog: {
      streams: components["schemas"]["AirbyteStreamAndConfiguration"][];
    };
    /** @description each stream is split in two parts; the immutable schema from source and mutable configuration for destination */
    AirbyteStreamAndConfiguration: {
      stream?: components["schemas"]["AirbyteStream"];
      config?: components["schemas"]["AirbyteStreamConfiguration"];
    };
    /** @description the immutable schema defined by the source */
    AirbyteStream: {
      /** @description Stream's name. */
      name: string;
      jsonSchema?: components["schemas"]["StreamJsonSchema"];
      supportedSyncModes?: components["schemas"]["SyncMode"][];
      /** @description If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup. */
      sourceDefinedCursor?: boolean;
      /** @description Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves. */
      defaultCursorField?: string[];
      /** @description If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves. */
      sourceDefinedPrimaryKey?: string[][];
      /** @description Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to. */
      namespace?: string;
    };
    /** @description Stream schema using Json Schema specs. */
    StreamJsonSchema: Record<string, never>;
    /** @description the mutable part of the stream to configure the destination */
    AirbyteStreamConfiguration: {
      syncMode: components["schemas"]["SyncMode"];
      /** @description Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored. */
      cursorField?: string[];
      destinationSyncMode: components["schemas"]["DestinationSyncMode"];
      /** @description Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored. */
      primaryKey?: string[][];
      /** @description Alias name to the stream to be used in the destination */
      aliasName?: string;
      /** @description If this is true, the stream is selected with all of its properties. For new connections, this considers if the stream is suggested or not */
      selected?: boolean;
      /** @description Does the connector suggest that this stream be enabled by default? */
      suggested?: boolean;
      /** @description Whether field selection should be enabled. If this is true, only the properties in `selectedFields` will be included. */
      fieldSelectionEnabled?: boolean;
      /** @description Paths to the fields that will be included in the configured catalog. This must be set if `fieldSelectedEnabled` is set. An empty list indicates that no properties will be included. */
      selectedFields?: components["schemas"]["SelectedFieldInfo"][];
    };
    /** @description Path to a field/column/property in a stream to be selected. For example, if the field to be selected is a database column called "foo", this will be ["foo"]. Use multiple path elements for nested schemas. */
    SelectedFieldInfo: {
      fieldPath?: string[];
    };
    /** @enum {string} */
    DataType: "string" | "number" | "boolean" | "object" | "array";
    /** Format: int64 */
    JobId: number;
    /** @enum {string} */
    JobConfigType: "check_connection_source" | "check_connection_destination" | "discover_schema" | "get_spec" | "sync" | "reset_connection";
    JobListRequestBody: {
      configTypes: components["schemas"]["JobConfigType"][];
      configId: string;
      /** @description If the job with this ID exists for the specified connection, returns the number of pages of jobs necessary to include this job. Returns an empty list if this job is specified and cannot be found in this connection. */
      includingJobId?: components["schemas"]["JobId"];
      pagination?: components["schemas"]["Pagination"];
    };
    JobIdRequestBody: {
      id: components["schemas"]["JobId"];
    };
    JobRead: {
      id: components["schemas"]["JobId"];
      configType: components["schemas"]["JobConfigType"];
      configId: string;
      enabledStreams?: components["schemas"]["StreamDescriptor"][];
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      updatedAt: number;
      /** Format: int64 */
      startedAt?: number;
      status: components["schemas"]["JobStatus"];
      resetConfig?: components["schemas"]["ResetConfig"];
    };
    /** @description contains information about how a reset was configured. only populated if the job was a reset. */
    ResetConfig: {
      streamsToReset?: components["schemas"]["StreamDescriptor"][];
    };
    StreamDescriptor: {
      name: string;
      namespace?: string;
    };
    JobDebugRead: {
      id: components["schemas"]["JobId"];
      configType: components["schemas"]["JobConfigType"];
      configId: string;
      status: components["schemas"]["JobStatus"];
      airbyteVersion: string;
      sourceDefinition: components["schemas"]["SourceDefinitionRead"];
      destinationDefinition: components["schemas"]["DestinationDefinitionRead"];
    };
    WorkflowStateRead: {
      running: boolean;
    };
    JobWithAttemptsRead: {
      job?: components["schemas"]["JobRead"];
      attempts?: components["schemas"]["AttemptRead"][];
    };
    /**
     * Format: int64
     * @description epoch time of the latest sync job. null if no sync job has taken place.
     */
    JobCreatedAt: number;
    /** @enum {string} */
    JobStatus: "pending" | "running" | "incomplete" | "failed" | "succeeded" | "cancelled";
    AttemptRead: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["AttemptStatus"];
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      updatedAt: number;
      /** Format: int64 */
      endedAt?: number;
      /** Format: int64 */
      bytesSynced?: number;
      /** Format: int64 */
      recordsSynced?: number;
      totalStats?: components["schemas"]["AttemptStats"];
      streamStats?: components["schemas"]["AttemptStreamStats"][];
      failureSummary?: components["schemas"]["AttemptFailureSummary"];
    };
    AttemptStats: {
      /** Format: int64 */
      recordsEmitted?: number;
      /** Format: int64 */
      bytesEmitted?: number;
      /** Format: int64 */
      stateMessagesEmitted?: number;
      /** Format: int64 */
      bytesCommitted?: number;
      /** Format: int64 */
      recordsCommitted?: number;
      /** Format: int64 */
      estimatedRecords?: number;
      /** Format: int64 */
      estimatedBytes?: number;
    };
    AttemptStreamStats: {
      streamName: string;
      streamNamespace?: string;
      stats: components["schemas"]["AttemptStats"];
    };
    AttemptFailureSummary: {
      failures: components["schemas"]["FailureReason"][];
      /** @description True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown. */
      partialSuccess?: boolean;
    };
    FailureReason: {
      failureOrigin?: components["schemas"]["FailureOrigin"];
      failureType?: components["schemas"]["FailureType"];
      externalMessage?: string;
      internalMessage?: string;
      stacktrace?: string;
      /** @description True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known. */
      retryable?: boolean;
      /** Format: int64 */
      timestamp: number;
    };
    /**
     * @description Indicates where the error originated. If not set, the origin of error is not well known.
     * @enum {string}
     */
    FailureOrigin: "source" | "destination" | "replication" | "persistence" | "normalization" | "dbt" | "airbyte_platform" | "unknown";
    /**
     * @description Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
     * @enum {string}
     */
    FailureType: "config_error" | "system_error" | "manual_cancellation" | "refresh_schema" | "heartbeat_timeout";
    /** @enum {string} */
    AttemptStatus: "running" | "failed" | "succeeded";
    JobReadList: {
      jobs: components["schemas"]["JobWithAttemptsRead"][];
      /**
       * Format: int64
       * @description the total count of jobs for the specified connection
       */
      totalJobCount: number;
    };
    JobInfoRead: {
      job: components["schemas"]["JobRead"];
      attempts: components["schemas"]["AttemptInfoRead"][];
    };
    JobInfoLightRead: {
      job: components["schemas"]["JobRead"];
    };
    JobOptionalRead: {
      job?: components["schemas"]["JobRead"];
    };
    JobDebugInfoRead: {
      job: components["schemas"]["JobDebugRead"];
      attempts: components["schemas"]["AttemptInfoRead"][];
      workflowState?: components["schemas"]["WorkflowStateRead"];
    };
    AttemptInfoRead: {
      attempt: components["schemas"]["AttemptRead"];
      logs: components["schemas"]["LogRead"];
    };
    LogRead: {
      logLines: string[];
    };
    SynchronousJobRead: {
      /** Format: uuid */
      id: string;
      configType: components["schemas"]["JobConfigType"];
      /** @description only present if a config id was provided. */
      configId?: string;
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      endedAt: number;
      succeeded: boolean;
      /** @default false */
      connectorConfigurationUpdated?: boolean;
      logs?: components["schemas"]["LogRead"];
      failureReason?: components["schemas"]["FailureReason"];
    };
    Pagination: {
      pageSize?: number;
      rowOffset?: number;
    };
    HealthCheckRead: {
      available: boolean;
    };
    CheckConnectionRead: {
      /** @enum {string} */
      status?: "succeeded" | "failed";
      message?: string;
      jobInfo: components["schemas"]["SynchronousJobRead"];
    };
    /** @description Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set. */
    ConnectionState: {
      stateType: components["schemas"]["ConnectionStateType"];
      connectionId: components["schemas"]["ConnectionId"];
      state?: components["schemas"]["StateBlob"];
      streamState?: components["schemas"]["StreamState"][];
      globalState?: components["schemas"]["GlobalState"];
    };
    StateBlob: Record<string, never>;
    StreamState: {
      streamDescriptor: components["schemas"]["StreamDescriptor"];
      streamState?: components["schemas"]["StateBlob"];
    };
    GlobalState: {
      shared_state?: components["schemas"]["StateBlob"];
      streamStates: components["schemas"]["StreamState"][];
    };
    /** @enum {string} */
    ConnectionStateType: "global" | "stream" | "legacy" | "not_set";
    /** @description Describes the difference between two Airbyte catalogs. */
    CatalogDiff: {
      /** @description list of stream transformations. order does not matter. */
      transforms: components["schemas"]["StreamTransform"][];
    };
    StreamTransform: {
      /** @enum {string} */
      transformType: "add_stream" | "remove_stream" | "update_stream";
      streamDescriptor: components["schemas"]["StreamDescriptor"];
      /** @description list of field transformations. order does not matter. */
      updateStream?: components["schemas"]["FieldTransform"][];
    };
    /** @description Describes the difference between two Streams. */
    FieldTransform: {
      /** @enum {string} */
      transformType: "add_field" | "remove_field" | "update_field_schema";
      fieldName: components["schemas"]["FieldName"];
      breaking: boolean;
      addField?: components["schemas"]["FieldAdd"];
      removeField?: components["schemas"]["FieldRemove"];
      updateFieldSchema?: components["schemas"]["FieldSchemaUpdate"];
    };
    FieldAdd: {
      schema?: components["schemas"]["FieldSchema"];
    };
    FieldRemove: {
      schema?: components["schemas"]["FieldSchema"];
    };
    FieldSchemaUpdate: {
      oldSchema: components["schemas"]["FieldSchema"];
      newSchema: components["schemas"]["FieldSchema"];
    };
    /** @description A field name is a list of strings that form the path to the field. */
    FieldName: string[];
    /** @description JSONSchema representation of the field */
    FieldSchema: Record<string, never>;
    /** @description actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level. */
    ActorDefinitionResourceRequirements: {
      default?: components["schemas"]["ResourceRequirements"];
      jobSpecific?: components["schemas"]["JobTypeResourceLimit"][];
    };
    ActorDefinitionRequestBody: {
      /** Format: uuid */
      actorDefinitionId: string;
      actorType: components["schemas"]["ActorType"];
    };
    /** @description describes a normalization config for destination definition */
    NormalizationDestinationDefinitionConfig: {
      /**
       * @description whether the destination definition supports normalization.
       * @default false
       */
      supported: boolean;
      /** @description a field indicating the name of the repository to be used for normalization. If the value of the flag is NULL - normalization is not used. */
      normalizationRepository?: string;
      /** @description a field indicating the tag of the docker repository to be used for normalization. */
      normalizationTag?: string;
      /** @description a field indicating the type of integration dialect to use for normalization. */
      normalizationIntegrationType?: string;
    };
    /** @description sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set. */
    JobTypeResourceLimit: {
      jobType: components["schemas"]["JobType"];
      resourceRequirements: components["schemas"]["ResourceRequirements"];
    };
    /**
     * @description enum that describes the different types of jobs that the platform runs.
     * @enum {string}
     */
    JobType: "get_spec" | "check_connection" | "discover_schema" | "sync" | "reset_connection" | "connection_updater" | "replicate";
    /** @description optional resource requirements to run workers (blank for unbounded allocations) */
    ResourceRequirements: {
      cpu_request?: string;
      cpu_limit?: string;
      memory_request?: string;
      memory_limit?: string;
    };
    /** @enum {string} */
    DbMigrationState: "pending" | "above_target" | "below_baseline" | "baseline" | "ignored" | "missing_success" | "missing_failed" | "success" | "undone" | "available" | "failed" | "out_of_order" | "future_success" | "future_failed" | "outdated" | "superseded" | "deleted";
    DbMigrationRead: {
      migrationType: string;
      migrationVersion: string;
      migrationDescription: string;
      migrationState?: components["schemas"]["DbMigrationState"];
      migratedBy?: string;
      /** Format: int64 */
      migratedAt?: number;
      migrationScript?: string;
    };
    DbMigrationReadList: {
      migrations?: components["schemas"]["DbMigrationRead"][];
    };
    DbMigrationExecutionRead: {
      initialVersion?: string;
      targetVersion?: string;
      executedMigrations?: components["schemas"]["DbMigrationRead"][];
    };
    /** @description The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema. */
    OAuthConfiguration: unknown;
    OAuthInputConfiguration: components["schemas"]["OAuthConfiguration"];
    AdvancedAuth: {
      /** @enum {string} */
      authFlowType?: "oauth2.0" | "oauth1.0";
      /** @description Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable. */
      predicateKey?: string[];
      /** @description Value of the predicate_key fields for the advanced auth to be applicable. */
      predicateValue?: string;
      oauthConfigSpecification?: components["schemas"]["OAuthConfigSpecification"];
    };
    OAuthConfigSpecification: {
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations used as input to OAuth.
       * Must be a valid non-nested JSON that refers to properties from ConnectorSpecification.connectionSpecification
       * using special annotation 'path_in_connector_config'.
       * These are input values the user is entering through the UI to authenticate to the connector, that might also shared
       * as inputs for syncing data via the connector.
       *
       * Examples:
       *
       * if no connector values is shared during oauth flow, oauth_user_input_from_connector_config_specification=[]
       * if connector values such as 'app_id' inside the top level are used to generate the API url for the oauth flow,
       *   oauth_user_input_from_connector_config_specification={
       *     app_id: {
       *       type: string
       *       path_in_connector_config: ['app_id']
       *     }
       *   }
       * if connector values such as 'info.app_id' nested inside another object are used to generate the API url for the oauth flow,
       *   oauth_user_input_from_connector_config_specification={
       *     app_id: {
       *       type: string
       *       path_in_connector_config: ['info', 'app_id']
       *     }
       *   }
       */
      oauthUserInputFromConnectorConfigSpecification?: components["schemas"]["OAuthConfiguration"];
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations produced by the OAuth flows as they are
       * returned by the distant OAuth APIs.
       * Must be a valid JSON describing the fields to merge back to `ConnectorSpecification.connectionSpecification`.
       * For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,
       *
       * Examples:
       *
       *     complete_oauth_output_specification={
       *       refresh_token: {
       *         type: string,
       *         path_in_connector_config: ['credentials', 'refresh_token']
       *       }
       *     }
       */
      completeOAuthOutputSpecification?: components["schemas"]["OAuthConfiguration"];
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations.
       * Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
       * server when completing an OAuth flow (typically exchanging an auth code for refresh token).
       *
       * Examples:
       *
       *     complete_oauth_server_input_specification={
       *       client_id: {
       *         type: string
       *       },
       *       client_secret: {
       *         type: string
       *       }
       *     }
       */
      completeOAuthServerInputSpecification?: components["schemas"]["OAuthConfiguration"];
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations that
       * also need to be merged back into the connector configuration at runtime.
       * This is a subset configuration of `complete_oauth_server_input_specification` that filters fields out to retain only the ones that
       * are necessary for the connector to function with OAuth. (some fields could be used during oauth flows but not needed afterwards, therefore
       * they would be listed in the `complete_oauth_server_input_specification` but not `complete_oauth_server_output_specification`)
       * Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
       * connector when using OAuth flow APIs.
       * These fields are to be merged back to `ConnectorSpecification.connectionSpecification`.
       * For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,
       *
       * Examples:
       *
       *       complete_oauth_server_output_specification={
       *         client_id: {
       *           type: string,
       *           path_in_connector_config: ['credentials', 'client_id']
       *         },
       *         client_secret: {
       *           type: string,
       *           path_in_connector_config: ['credentials', 'client_secret']
       *         }
       *       }
       */
      completeOAuthServerOutputSpecification?: components["schemas"]["OAuthConfiguration"];
    };
    SourceOauthConsentRequest: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      workspaceId: components["schemas"]["WorkspaceId"];
      /** @description The url to redirect to after getting the user consent */
      redirectUrl: string;
      oAuthInputConfiguration?: components["schemas"]["OAuthInputConfiguration"];
      sourceId?: components["schemas"]["SourceId"];
    };
    DestinationOauthConsentRequest: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      workspaceId: components["schemas"]["WorkspaceId"];
      /** @description The url to redirect to after getting the user consent */
      redirectUrl: string;
      oAuthInputConfiguration?: components["schemas"]["OAuthInputConfiguration"];
      destinationId?: components["schemas"]["DestinationId"];
    };
    OAuthConsentRead: {
      consentUrl: string;
    };
    CompleteSourceOauthRequest: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      workspaceId: components["schemas"]["WorkspaceId"];
      /** @description When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
      redirectUrl?: string;
      /** @description The query parameters present in the redirect URL after a user granted consent e.g auth code */
      queryParams?: {
        [key: string]: unknown;
      };
      oAuthInputConfiguration?: components["schemas"]["OAuthInputConfiguration"];
      /**
       * @description If set to true, returns a secret coordinate which references the stored tokens. By default, returns raw tokens.
       * @default false
       */
      returnSecretCoordinate?: boolean;
      sourceId?: components["schemas"]["SourceId"];
    };
    RevokeSourceOauthTokensRequest: {
      workspaceId: components["schemas"]["WorkspaceId"];
      sourceId: components["schemas"]["SourceId"];
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
    };
    CompleteDestinationOAuthRequest: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      workspaceId: components["schemas"]["WorkspaceId"];
      /** @description When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
      redirectUrl?: string;
      /** @description The query parameters present in the redirect URL after a user granted consent e.g auth code */
      queryParams?: {
        [key: string]: unknown;
      };
      oAuthInputConfiguration?: components["schemas"]["OAuthInputConfiguration"];
      destinationId?: components["schemas"]["DestinationId"];
    };
    CompleteOAuthResponse: {
      request_succeeded: boolean;
      request_error?: string;
      auth_payload: {
        [key: string]: unknown;
      };
    };
    SetInstancewideSourceOauthParamsRequestBody: {
      sourceDefinitionId: components["schemas"]["SourceDefinitionId"];
      params: {
        [key: string]: unknown;
      };
    };
    SetInstancewideDestinationOauthParamsRequestBody: {
      destinationDefinitionId: components["schemas"]["DestinationDefinitionId"];
      params: {
        [key: string]: unknown;
      };
    };
    WorkspaceOverrideOauthParamsRequestBody: {
      /** Format: uuid */
      definitionId: string;
      params: {
        [key: string]: unknown;
      };
      workspaceId: components["schemas"]["WorkspaceId"];
      actorType: components["schemas"]["ActorType"];
    };
    /** @enum {string} */
    ActorType: "source" | "destination";
    /** @description Summary of source and destination definitions that could be updated */
    WebBackendCheckUpdatesRead: {
      destinationDefinitions: number;
      sourceDefinitions: number;
    };
    WebBackendConnectionListRequestBody: {
      workspaceId: components["schemas"]["WorkspaceId"];
      sourceId?: components["schemas"]["SourceId"][];
      destinationId?: components["schemas"]["DestinationId"][];
    };
    /** @description Information about a connection that shows up in the connection list view. */
    WebBackendConnectionListItem: {
      connectionId: components["schemas"]["ConnectionId"];
      name: string;
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status: components["schemas"]["ConnectionStatus"];
      source: components["schemas"]["SourceSnippetRead"];
      destination: components["schemas"]["DestinationSnippetRead"];
      latestSyncJobCreatedAt?: components["schemas"]["JobCreatedAt"];
      latestSyncJobStatus?: components["schemas"]["JobStatus"];
      isSyncing: boolean;
      schemaChange: components["schemas"]["SchemaChange"];
    };
    WebBackendConnectionRead: {
      connectionId: components["schemas"]["ConnectionId"];
      name: string;
      namespaceDefinition?: components["schemas"]["NamespaceDefinitionType"];
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string;
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string;
      sourceId: components["schemas"]["SourceId"];
      destinationId: components["schemas"]["DestinationId"];
      syncCatalog: components["schemas"]["AirbyteCatalog"];
      schedule?: components["schemas"]["ConnectionSchedule"];
      scheduleType?: components["schemas"]["ConnectionScheduleType"];
      scheduleData?: components["schemas"]["ConnectionScheduleData"];
      status: components["schemas"]["ConnectionStatus"];
      operationIds?: components["schemas"]["OperationId"][];
      source: components["schemas"]["SourceRead"];
      destination: components["schemas"]["DestinationRead"];
      operations?: components["schemas"]["OperationRead"][];
      latestSyncJobCreatedAt?: components["schemas"]["JobCreatedAt"];
      latestSyncJobStatus?: components["schemas"]["JobStatus"];
      isSyncing: boolean;
      resourceRequirements?: components["schemas"]["ResourceRequirements"];
      /** Format: uuid */
      catalogId?: string;
      catalogDiff?: components["schemas"]["CatalogDiff"];
      geography?: components["schemas"]["Geography"];
      schemaChange: components["schemas"]["SchemaChange"];
      notifySchemaChanges: boolean;
      notifySchemaChangesByEmail: boolean;
      nonBreakingChangesPreference: components["schemas"]["NonBreakingChangesPreference"];
    };
    /** @enum {string} */
    NonBreakingChangesPreference: "ignore" | "disable" | "propagate_columns" | "propagate_fully";
    WebBackendConnectionReadList: {
      connections: components["schemas"]["WebBackendConnectionListItem"][];
    };
    /** @enum {string} */
    SyncMode: "full_refresh" | "incremental";
    /** @enum {string} */
    DestinationSyncMode: "append" | "overwrite" | "append_dedup";
    /**
     * Format: binary
     * @description Tarball Archive (.tar.gz) of Airbyte Configuration and Database
     */
    AirbyteArchive: string;
    ImportRead: {
      /** @enum {string} */
      status: "succeeded" | "failed";
      reason?: string;
    };
    /** Format: uuid */
    ResourceId: string;
    UploadRead: {
      /** @enum {string} */
      status: "succeeded" | "failed";
      resourceId?: components["schemas"]["ResourceId"];
    };
    ImportRequestBody: {
      resourceId: components["schemas"]["ResourceId"];
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    /** Format: int32 */
    AttemptNumber: number;
    WorkflowId: string;
    SetWorkflowInAttemptRequestBody: {
      jobId: components["schemas"]["JobId"];
      attemptNumber: components["schemas"]["AttemptNumber"];
      workflowId: components["schemas"]["WorkflowId"];
      /** @default */
      processingTaskQueue?: string;
    };
    SaveStatsRequestBody: {
      jobId: components["schemas"]["JobId"];
      attemptNumber: components["schemas"]["AttemptNumber"];
      stats: components["schemas"]["AttemptStats"];
      streamStats?: components["schemas"]["AttemptStreamStats"][];
    };
    AttemptSyncConfig: {
      sourceConfiguration: components["schemas"]["SourceConfiguration"];
      destinationConfiguration: components["schemas"]["DestinationConfiguration"];
      state?: components["schemas"]["ConnectionState"];
    };
    SaveAttemptSyncConfigRequestBody: {
      jobId: components["schemas"]["JobId"];
      attemptNumber: components["schemas"]["AttemptNumber"];
      syncConfig: components["schemas"]["AttemptSyncConfig"];
    };
    InternalOperationResult: {
      succeeded: boolean;
    };
    DiscoverCatalogResult: {
      /** Format: uuid */
      catalogId: string;
    };
    AttemptNormalizationStatusReadList: {
      attemptNormalizationStatuses?: components["schemas"]["AttemptNormalizationStatusRead"][];
    };
    AttemptNormalizationStatusRead: {
      attemptNumber?: components["schemas"]["AttemptNumber"];
      hasRecordsCommitted?: boolean;
      /** Format: int64 */
      recordsCommitted?: number;
      hasNormalizationFailed?: boolean;
    };
    /** Format: uuid */
    StreamStatusId: string;
    /**
     * @description Values:
     *   * `PENDING` - The stream operation has been selected to run
     *   * `RUNNING` - The stream operation is running
     *   * `COMPLETE` - The stream operation ran successfully to completion
     *   * `INCOMPLETE` - The stream operation has terminated in an incomplete state.
     *   See StreamStatusIncompleteRunCause for more details.
     *
     * @enum {string}
     */
    StreamStatusRunState: "PENDING" | "RUNNING" | "COMPLETE" | "INCOMPLETE";
    /**
     * @description Values:
     *   * `FAILED` - A failure has occurred
     *   * `CANCELED` - The run has been canceled
     *
     * @enum {string}
     */
    StreamStatusIncompleteRunCause: "FAILED" | "CANCELED";
    /** @enum {string} */
    StreamStatusJobType: "SYNC" | "RESET";
    StreamStatusListRequestBody: {
      attemptNumber?: components["schemas"]["AttemptNumber"];
      connectionId?: components["schemas"]["ConnectionId"];
      jobId?: components["schemas"]["JobId"];
      jobType?: components["schemas"]["StreamStatusJobType"];
      pagination: components["schemas"]["Pagination"];
      streamName?: string;
      streamNamespace?: string;
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    StreamStatusCreateRequestBody: {
      attemptNumber: components["schemas"]["AttemptNumber"];
      connectionId: components["schemas"]["ConnectionId"];
      jobId: components["schemas"]["JobId"];
      incompleteRunCause?: components["schemas"]["StreamStatusIncompleteRunCause"];
      jobType: components["schemas"]["StreamStatusJobType"];
      runState: components["schemas"]["StreamStatusRunState"];
      streamName: string;
      streamNamespace?: string;
      /** Format: int64 */
      transitionedAt: number;
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    StreamStatusUpdateRequestBody: WithRequired<{
      id: components["schemas"]["StreamStatusId"];
    } & components["schemas"]["StreamStatusCreateRequestBody"], "id">;
    StreamStatusRead: {
      attemptNumber: components["schemas"]["AttemptNumber"];
      connectionId: components["schemas"]["ConnectionId"];
      id: components["schemas"]["StreamStatusId"];
      jobId: components["schemas"]["JobId"];
      incompleteRunCause?: components["schemas"]["StreamStatusIncompleteRunCause"];
      jobType: components["schemas"]["StreamStatusJobType"];
      runState: components["schemas"]["StreamStatusRunState"];
      streamName: string;
      streamNamespace: string;
      /** Format: int64 */
      transitionedAt: number;
      workspaceId: components["schemas"]["WorkspaceId"];
    };
    StreamStatusReadList: {
      streamStatuses?: components["schemas"]["StreamStatusRead"][];
    };
    InvalidInputProperty: {
      propertyPath: string;
      invalidValue?: string;
      message?: string;
    };
    NotFoundKnownExceptionInfo: {
      id?: string;
      message: string;
      exceptionClassName?: string;
      exceptionStack?: string[];
      rootCauseExceptionClassName?: string;
      rootCauseExceptionStack?: string[];
    };
    KnownExceptionInfo: {
      message: string;
      exceptionClassName?: string;
      exceptionStack?: string[];
      rootCauseExceptionClassName?: string;
      rootCauseExceptionStack?: string[];
    };
    InvalidInputExceptionInfo: {
      message: string;
      exceptionClassName?: string;
      exceptionStack?: string[];
      validationErrors: components["schemas"]["InvalidInputProperty"][];
    };
  };
  responses: {
    /** @description Object with given id was not found. */
    NotFoundResponse: {
      content: {
        "application/json": components["schemas"]["NotFoundKnownExceptionInfo"];
      };
    };
    /** @description Input failed validation */
    InvalidInputResponse: {
      content: {
        "application/json": components["schemas"]["InvalidInputExceptionInfo"];
      };
    };
    /** @description Exception occurred; see message for details. */
    ExceptionResponse: {
      content: {
        "application/json": components["schemas"]["KnownExceptionInfo"];
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Creates a workspace */
  createWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Deletes a workspace */
  deleteWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** List all workspaces registered in the current Airbyte deployment */
  listWorkspaces: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceReadList"];
        };
      };
    };
  };
  /** Find workspace by ID */
  getWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Find workspace by slug */
  getWorkspaceBySlug: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SlugRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Find workspace by connection id */
  getWorkspaceByConnectionId: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update workspace state */
  updateWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update workspace name */
  updateWorkspaceName: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceUpdateName"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update workspace feedback state */
  updateWorkspaceFeedback: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceGiveFeedback"];
      };
    };
    responses: {
      /** @description The feedback state has been properly updated */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
    };
  };
  /** Try sending a notifications */
  tryNotificationConfig: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Notification"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["NotificationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update a sourceDefinition */
  updateSourceDefinition: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SourceDefinitionUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** List all the sourceDefinitions the current Airbyte deployment is configured to use */
  listSourceDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionReadList"];
        };
      };
    };
  };
  /**
   * List the latest sourceDefinitions Airbyte supports
   * @description Guaranteed to retrieve the latest information on supported sources.
   */
  listLatestSourceDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionReadList"];
        };
      };
    };
  };
  /** Get source */
  getSourceDefinition: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDefinitionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Delete a source definition */
  deleteSourceDefinition: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDefinitionIdRequestBody"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
  listPrivateSourceDefinitions: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["PrivateSourceDefinitionReadList"];
        };
      };
    };
  };
  /** List all the sourceDefinitions the given workspace is configured to use */
  listSourceDefinitionsForWorkspace: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionReadList"];
        };
      };
    };
  };
  /** Creates a custom sourceDefinition for the given workspace */
  createCustomSourceDefinition: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CustomSourceDefinitionCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get a sourceDefinition that is configured for the given workspace */
  getSourceDefinitionForWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** grant a private, non-custom sourceDefinition to a given workspace */
  grantSourceDefinitionToWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["PrivateSourceDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** revoke a grant to a private, non-custom sourceDefinition from a given workspace */
  revokeSourceDefinitionFromWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get specification for a SourceDefinition. */
  getSourceDefinitionSpecification: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionSpecificationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get specification for a source. */
  getSpecificationForSourceId: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionSpecificationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Create a declarative manifest to be used by the specified source definition */
  createDeclarativeSourceDefinitionManifest: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeclarativeSourceDefinitionCreateManifestRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      201: {
        content: never;
      };
      /** @description Definition is not declarative source */
      400: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      /** @description Version already exists for definition id */
      409: {
        content: never;
      };
    };
  };
  /** Update the declarative manifest version for a source */
  updateDeclarativeManifestVersion: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateActiveManifestRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
    };
  };
  /** List all available declarative manifest versions of a declarative source definition */
  listDeclarativeManifests: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListDeclarativeManifestsRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DeclarativeManifestsReadList"];
        };
      };
      /** @description Definition is not declarative source */
      400: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
    };
  };
  /** Create new connector builder project */
  createConnectorBuilderProject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectorBuilderProjectWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      201: {
        content: {
          "application/json": components["schemas"]["ConnectorBuilderProjectIdWithWorkspaceId"];
        };
      };
    };
  };
  /** Publish a connector to the workspace */
  publishConnectorBuilderProject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectorBuilderPublishRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDefinitionIdBody"];
        };
      };
    };
  };
  /** Update connector builder project */
  updateConnectorBuilderProject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExistingConnectorBuilderProjectWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      204: {
        content: never;
      };
    };
  };
  /** Deletes connector builder project */
  deleteConnectorBuilderProject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectorBuilderProjectIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      204: {
        content: never;
      };
    };
  };
  /** List connector builder projects for workspace */
  listConnectorBuilderProjects: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectorBuilderProjectReadList"];
        };
      };
    };
  };
  /** Get a connector builder project with draft manifest */
  getConnectorBuilderProject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectorBuilderProjectIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectorBuilderProjectRead"];
        };
      };
    };
  };
  /** Create a source */
  createSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update a source */
  updateSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Partially update a source */
  partialUpdateSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PartialSourceUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /**
   * List sources for workspace
   * @description List sources for workspace. Does not return deleted sources.
   */
  listSourcesForWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get source */
  getSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get most recent ActorCatalog for source */
  getMostRecentSourceActorCatalog: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ActorCatalogWithUpdatedAt"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Search sources */
  searchSources: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceSearch"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceReadList"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Clone source */
  cloneSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceCloneRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Delete a source */
  deleteSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceIdRequestBody"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Check connection to the source */
  checkConnectionToSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CheckConnectionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Check connection for a proposed update to a source */
  checkConnectionToSourceForUpdate: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CheckConnectionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Discover the schema catalog of the source */
  discoverSchemaForSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDiscoverSchemaRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDiscoverSchemaRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Auto propagate the change on a catalog to a catalog saved in the DB. It will fetch all the connections linked to a source id and apply the provided diff to their catalog. */
  applySchemaChangeForSource: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceAutoPropagateChange"];
      };
    };
    responses: {
      /** @description The schema was properly auto propagate */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Should only called from worker, to write result from discover activity back to DB. */
  writeDiscoverCatalogResult: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceDiscoverSchemaWriteRequestBody"];
      };
    };
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          "application/json": components["schemas"]["DiscoverCatalogResult"];
        };
      };
    };
  };
  /** Update destinationDefinition */
  updateDestinationDefinition: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationDefinitionUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** List all the destinationDefinitions the current Airbyte deployment is configured to use */
  listDestinationDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionReadList"];
        };
      };
    };
  };
  /**
   * List the latest destinationDefinitions Airbyte supports
   * @description Guaranteed to retrieve the latest information on supported destinations.
   */
  listLatestDestinationDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionReadList"];
        };
      };
    };
  };
  /** Get destinationDefinition */
  getDestinationDefinition: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationDefinitionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Delete a destination definition */
  deleteDestinationDefinition: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationDefinitionIdRequestBody"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
  listPrivateDestinationDefinitions: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["PrivateDestinationDefinitionReadList"];
        };
      };
    };
  };
  /** List all the destinationDefinitions the given workspace is configured to use */
  listDestinationDefinitionsForWorkspace: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionReadList"];
        };
      };
    };
  };
  /** Creates a custom destinationDefinition for the given workspace */
  createCustomDestinationDefinition: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CustomDestinationDefinitionCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get a destinationDefinition that is configured for the given workspace */
  getDestinationDefinitionForWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** grant a private, non-custom destinationDefinition to a given workspace */
  grantDestinationDefinitionToWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["PrivateDestinationDefinitionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** revoke a grant to a private, non-custom destinationDefinition from a given workspace */
  revokeDestinationDefinitionFromWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get specification for a destinationDefinition */
  getDestinationDefinitionSpecification: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationDefinitionIdWithWorkspaceId"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionSpecificationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get specification for a destination */
  getSpecificationForDestinationId: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationDefinitionSpecificationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Create a destination */
  createDestination: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update a destination */
  updateDestination: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update a destination partially */
  partialUpdateDestination: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PartialDestinationUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** List configured destinations for a workspace */
  listDestinationsForWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get configured destination */
  getDestination: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Search destinations */
  searchDestinations: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationSearch"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationReadList"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Check connection to the destination */
  checkConnectionToDestination: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CheckConnectionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Check connection for a proposed update to a destination */
  checkConnectionToDestinationForUpdate: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CheckConnectionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Delete the destination */
  deleteDestination: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationIdRequestBody"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Clone destination */
  cloneDestination: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationCloneRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["DestinationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Create a connection between a source and a destination */
  createConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /**
   * Update a connection
   * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
   * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
   * with the catalog from the request. This means that to modify a single stream, the entire new catalog
   * containing the updated stream needs to be sent.
   */
  updateConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /**
   * Returns all connections for a workspace.
   * @description List connections for workspace. Does not return deleted connections.
   */
  listConnectionsForWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /**
   * Returns all connections for a workspace, including deleted connections.
   * @description List connections for workspace, including deleted connections.
   */
  listAllConnectionsForWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get a connection */
  getConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** List all connections that use the provided actor definition */
  listConnectionsByActorDefinition: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ActorDefinitionRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Fetch the current state for a connection. */
  getState: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionState"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Create or update the state for a connection. */
  createOrUpdateState: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionStateCreateOrUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionState"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Search connections */
  searchConnections: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionSearch"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionReadList"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Delete a connection */
  deleteConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Trigger a manual sync of the connection */
  syncConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobInfoRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state. */
  resetConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobInfoRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Reset the data for a specific stream in the connection. Deletes data generated by the stream in the destination. Resets any cursors back to initial state. */
  resetConnectionStream: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionStreamRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobInfoRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Check if an operation to be created is valid */
  checkOperation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["OperatorConfiguration"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CheckOperationRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Create an operation to be applied as part of a connection pipeline */
  createOperation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["OperationCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["OperationRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Update an operation */
  updateOperation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["OperationUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["OperationRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /**
   * Returns all operations for a connection.
   * @description List operations for connection.
   */
  listOperationsForConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["OperationReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Returns an operation */
  getOperation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["OperationIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["OperationRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Delete an operation */
  deleteOperation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["OperationIdRequestBody"];
      };
    };
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never;
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Run check connection for a given source configuration */
  executeSourceCheckConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceCoreConfig"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CheckConnectionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Run discover schema for a given source a source configuration */
  executeSourceDiscoverSchema: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceCoreConfig"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["SourceDiscoverSchemaRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Run check connection for a given destination configuration */
  executeDestinationCheckConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationCoreConfig"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CheckConnectionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
  setInstancewideSourceOauthParams: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetInstancewideSourceOauthParamsRequestBody"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: never;
      };
      400: components["responses"]["ExceptionResponse"];
      404: components["responses"]["NotFoundResponse"];
    };
  };
  /** Given a source connector definition ID, return the URL to the consent screen where to redirect the user to. */
  getSourceOAuthConsent: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SourceOauthConsentRequest"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthConsentRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Given a source def ID generate an access/refresh token etc. */
  completeSourceOAuth: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CompleteSourceOauthRequest"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CompleteOAuthResponse"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Given a source definition ID and workspace ID revoke access/refresh token etc. */
  revokeSourceOAuthTokens: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RevokeSourceOauthTokensRequest"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: never;
      };
      400: components["responses"]["ExceptionResponse"];
      404: components["responses"]["NotFoundResponse"];
    };
  };
  /** Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to. */
  getDestinationOAuthConsent: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DestinationOauthConsentRequest"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthConsentRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Given a destination def ID generate an access/refresh token etc. */
  completeDestinationOAuth: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CompleteDestinationOAuthRequest"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["CompleteOAuthResponse"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
  setInstancewideDestinationOauthParams: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetInstancewideDestinationOauthParamsRequestBody"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: never;
      };
      400: components["responses"]["ExceptionResponse"];
      404: components["responses"]["NotFoundResponse"];
    };
  };
  /** Returns a summary of source and destination definitions that could be updated. */
  webBackendCheckUpdates: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WebBackendCheckUpdatesRead"];
        };
      };
    };
  };
  /** Returns all non-deleted connections for a workspace. */
  webBackendListConnectionsForWorkspace: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebBackendConnectionListRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WebBackendConnectionReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get a connection */
  webBackendGetConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebBackendConnectionRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WebBackendConnectionRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Create a connection */
  webBackendCreateConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebBackendConnectionCreate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WebBackendConnectionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /**
   * Update a connection
   * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
   * Any operations that lack an ID will be created. Then, the newly created operationId will be applied to the
   * connection along with the rest of the operationIds in the request body.
   * Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
   * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
   * with the catalog from the request. This means that to modify a single stream, the entire new catalog
   * containing the updated stream needs to be sent.
   */
  webBackendUpdateConnection: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WebBackendConnectionUpdate"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WebBackendConnectionRead"];
        };
      };
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Fetch the current state type for a connection. */
  getStateType: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionStateType"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Returns the current state of a workspace */
  webBackendGetWorkspaceState: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WebBackendWorkspaceState"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WebBackendWorkspaceStateResult"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /**
   * Returns available geographies can be selected to run data syncs in a particular geography.
   * The 'auto' entry indicates that the sync will be automatically assigned to a geography according
   * to the platform default behavior. Entries other than 'auto' are two-letter country codes that
   * follow the ISO 3166-1 alpha-2 standard.
   *
   * @description Returns all available geographies in which a data sync can run.
   */
  webBackendListGeographies: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["WebBackendGeographiesListResult"];
        };
      };
    };
  };
  /** Returns recent jobs for a connection. Jobs are returned in descending order by createdAt. */
  listJobsFor: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["JobListRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobReadList"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get information about a job */
  getJobInfo: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["JobIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobInfoRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  getLastReplicationJob: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobOptionalRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get information about a job excluding logs */
  getJobInfoWithoutLogs: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["JobIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobInfoRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get information about a job excluding attempt info and logs */
  getJobInfoLight: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["JobIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobInfoLightRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Cancels a job */
  cancelJob: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["JobIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobInfoRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Gets all information needed to debug this job */
  getJobDebugInfo: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["JobIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["JobDebugInfoRead"];
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Get normalization status to determine if we can bypass normalization phase */
  getAttemptNormalizationStatusesForJob: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["JobIdRequestBody"];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["AttemptNormalizationStatusReadList"];
        };
      };
    };
  };
  /** Health Check */
  getHealthCheck: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["HealthCheckRead"];
        };
      };
    };
  };
  /** Get logs */
  getLogs: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["LogsRequestBody"];
      };
    };
    responses: {
      /** @description Returns the log file */
      200: {
        content: {
          "text/plain": string;
        };
      };
      404: components["responses"]["NotFoundResponse"];
      422: components["responses"]["InvalidInputResponse"];
    };
  };
  /** Returns the openapi specification */
  getOpenApiSpec: {
    responses: {
      /** @description Returns the openapi specification file */
      200: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** For worker to register the workflow id in attempt. */
  setWorkflowInAttempt: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetWorkflowInAttemptRequestBody"];
      };
    };
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          "application/json": components["schemas"]["InternalOperationResult"];
        };
      };
    };
  };
  /** For worker to set sync stats of a running attempt. */
  saveStats: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SaveStatsRequestBody"];
      };
    };
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          "application/json": components["schemas"]["InternalOperationResult"];
        };
      };
    };
  };
  /** For worker to save the AttemptSyncConfig for an attempt. */
  saveSyncConfig: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SaveAttemptSyncConfigRequestBody"];
      };
    };
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          "application/json": components["schemas"]["InternalOperationResult"];
        };
      };
    };
  };
  /** Gets a list of stream statuses filtered by parameters (with AND semantics). */
  getStreamStatuses: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["StreamStatusListRequestBody"];
      };
    };
    responses: {
      /** @description Successfully queried stream statuses. */
      200: {
        content: {
          "application/json": components["schemas"]["StreamStatusReadList"];
        };
      };
    };
  };
  /** Creates a stream status. */
  createStreamStatus: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["StreamStatusCreateRequestBody"];
      };
    };
    responses: {
      /** @description Successfully created stream status. */
      201: {
        content: {
          "application/json": components["schemas"]["StreamStatusRead"];
        };
      };
    };
  };
  /** Updates a stream status. */
  updateStreamStatus: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["StreamStatusUpdateRequestBody"];
      };
    };
    responses: {
      /** @description Successfully updated stream status. */
      200: {
        content: {
          "application/json": components["schemas"]["StreamStatusRead"];
        };
      };
      /** @description Successfully created stream status. */
      201: {
        content: {
          "application/json": components["schemas"]["StreamStatusRead"];
        };
      };
    };
  };
}
